<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minecraft House Viewer</title>
  <style>
    :root {
      --bg-900: #11131a;
      --bg-800: #191c25;
      --bg-700: #202431;
      --accent-500: #4da3ff;
      --accent-400: #3894f5;
      --neutral-400: #c5cbd8;
      --neutral-300: #949ab0;
      --border-color: #2e3447;
      --error: #ff6b6b;
      --success: #58d68d;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: var(--bg-900);
      color: var(--neutral-400);
      min-height: 100vh;
      display: flex;
      justify-content: center;
    }

    #app {
      width: 100%;
      max-width: 1400px;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    header {
      background: var(--bg-800);
      border-bottom: 1px solid var(--border-color);
      padding: 1.25rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
    }

    header h1 {
      font-size: 1.5rem;
      color: #fff;
    }

    .control-group {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
    }

    label[for="fileInput"] {
      background: var(--accent-500);
      color: #fff;
      padding: 0.6rem 1.5rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 600;
      transition: background 0.2s ease;
    }

    label[for="fileInput"]:hover {
      background: var(--accent-400);
    }

    input[type="file"] {
      display: none;
    }

    .status {
      font-size: 0.9rem;
      min-width: 200px;
    }

    .status.--error {
      color: var(--error);
    }

    .status.--success {
      color: var(--success);
    }

    main {
      flex: 1;
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: 1px;
      background: var(--border-color);
      min-height: 0;
    }

    .sidebar {
      background: var(--bg-800);
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      overflow-y: auto;
    }

    .panel-heading {
      font-size: 0.85rem;
      letter-spacing: 0.08em;
      color: var(--neutral-300);
      text-transform: uppercase;
      margin-bottom: 0.75rem;
    }

    .stats-grid {
      display: grid;
      gap: 0.5rem;
      font-size: 0.95rem;
    }

    .stat-item strong {
      color: #fff;
      font-weight: 600;
    }

    .instructions {
      background: var(--bg-700);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 1rem 1.25rem;
      line-height: 1.6;
      font-size: 0.9rem;
    }

    .instructions ol {
      padding-left: 1.25rem;
      margin-top: 0.5rem;
    }

    .instructions code {
      background: rgba(255, 255, 255, 0.05);
      padding: 0.1rem 0.35rem;
      border-radius: 3px;
    }

    .canvas-panel {
      background: linear-gradient(180deg, #8ec5ff 0%, #5fa7f3 100%);
      position: relative;
      overflow: hidden;
    }

    .controls-hint {
      position: absolute;
      left: 1.25rem;
      bottom: 1.25rem;
      background: rgba(17, 19, 26, 0.85);
      padding: 0.75rem 1rem;
      border-radius: 4px;
      font-size: 0.85rem;
      line-height: 1.5;
    }

    .controls-hint strong {
      color: #fff;
      display: block;
      margin-bottom: 0.25rem;
    }

    .aux-hint {
      color: var(--neutral-300);
      font-size: 0.85rem;
      margin-top: 0.75rem;
    }

    @media (max-width: 1024px) {
      main {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
      }

      .sidebar {
        border-bottom: 1px solid var(--border-color);
      }
    }

    @media (max-width: 640px) {
      header {
        flex-direction: column;
        align-items: flex-start;
      }

      .control-group {
        width: 100%;
        justify-content: space-between;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>Minecraft House Viewer</h1>
      <div class="control-group">
        <label for="fileInput">Load house JSON</label>
        <input type="file" id="fileInput" accept=".json" />
        <span id="status" class="status">Awaiting input…</span>
      </div>
    </header>

    <main>
      <aside class="sidebar">
        <section>
          <div class="panel-heading">Summary</div>
          <div id="stats" class="stats-grid">
            <div class="stat-item">No data available.</div>
          </div>
        </section>

        <section class="instructions">
          <div class="panel-heading">Workflow</div>
          <ol>
            <li>Run <code>python/generator.py</code> to produce <code>house.json</code>.</li>
            <li>Choose the generated file via <em>Load house JSON</em>.</li>
            <li>Inspect block counts and navigate the 3D view.</li>
          </ol>
          <p class="aux-hint">Place <code>house.json</code> next to this HTML file to auto-load on refresh.</p>
        </section>
      </aside>

      <section id="canvas-container" class="canvas-panel" aria-label="3D house viewport">
        <div class="controls-hint">
          <strong>Camera controls</strong>
          <div>Left click + drag: orbit</div>
          <div>Scroll: zoom</div>
        </div>
      </section>
    </main>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';

    /**
     * @typedef {Object} BlockMetadata
     * @property {string} [facing] Cardinal direction for the stair orientation.
     * @property {boolean} [upsideDown] Indicates whether the stair is inverted.
     */

    /**
     * @typedef {Object} BlockData
     * @property {number} x X coordinate in the grid.
     * @property {number} y Y coordinate in the grid.
     * @property {number} z Z coordinate in the grid.
     * @property {string} type Supported values: "block" or "stair".
     * @property {BlockMetadata} [metadata] Optional configuration for stairs.
     */

    /**
     * @typedef {Object} HouseDimensions
     * @property {number} width Width expressed in blocks.
     * @property {number} height Height expressed in blocks.
     * @property {number} depth Depth expressed in blocks.
     */

    /**
     * @typedef {Object} HouseData
     * @property {HouseDimensions} dimensions Spatial limits of the house.
     * @property {BlockData[]} blocks Collection of all blocks to render.
     */

    const PALETTE = {
      block: 0x8b4513,
      stair: 0xcd853f,
    };

    /**
     * Handles Three.js rendering for the Minecraft house preview.
     */
    class HouseRenderer {
      /**
       * @param {HTMLElement} container Host element for the WebGL canvas.
       */
      constructor(container) {
        this.container = container;
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x87ceeb);

        this.camera = new THREE.PerspectiveCamera(
          75,
          container.clientWidth / container.clientHeight,
          0.1,
          1000
        );

        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setPixelRatio(window.devicePixelRatio || 1);
        this.renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(this.renderer.domElement);

        this.controls = {
          azimuth: Math.PI / 4,
          elevation: Math.PI / 6,
          distance: 20,
        };

        this.houseGroup = new THREE.Group();
        this.scene.add(this.houseGroup);

        this.#addLighting();
        this.#addGrid();
        this.#registerInteractions();

        this.animate = this.animate.bind(this);
        this.updateCamera();
        this.animate();
      }

      /**
       * Adds ambient and directional lights to the scene.
       * @private
       */
      #addLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        this.scene.add(directionalLight);
      }

      /**
       * Adds a reference grid to help with orientation.
       * @private
       */
      #addGrid() {
        const gridHelper = new THREE.GridHelper(50, 50);
        this.scene.add(gridHelper);
      }

      /**
       * Wires up mouse, wheel, and resize handlers for camera control.
       * @private
       */
      #registerInteractions() {
        let isDragging = false;
        let previous = { x: 0, y: 0 };
        const canvas = this.renderer.domElement;

        canvas.addEventListener('mousedown', (event) => {
          isDragging = true;
          previous = { x: event.clientX, y: event.clientY };
        });

        canvas.addEventListener('mousemove', (event) => {
          if (!isDragging) return;
          const deltaX = event.clientX - previous.x;
          const deltaY = event.clientY - previous.y;

          this.controls.azimuth -= deltaX * 0.01;
          this.controls.elevation = THREE.MathUtils.clamp(
            this.controls.elevation + deltaY * 0.01,
            0.1,
            Math.PI / 2 - 0.1
          );

          previous = { x: event.clientX, y: event.clientY };
          this.updateCamera();
        });

        window.addEventListener('mouseup', () => {
          isDragging = false;
        });

        canvas.addEventListener('wheel', (event) => {
          event.preventDefault();
          this.controls.distance = THREE.MathUtils.clamp(
            this.controls.distance + event.deltaY * 0.01,
            5,
            100
          );
          this.updateCamera();
        });

        window.addEventListener('resize', () => this.handleResize());
      }

      /**
       * Keeps the camera pointed at the center of the model.
       * @param {number} centerX X coordinate of the focal point.
       * @param {number} centerY Y coordinate of the focal point.
       * @param {number} centerZ Z coordinate of the focal point.
       */
      updateCamera(centerX = 0, centerY = 3, centerZ = 0) {
        const { azimuth, elevation, distance } = this.controls;

        this.camera.position.x = centerX + distance * Math.sin(elevation) * Math.cos(azimuth);
        this.camera.position.y = centerY + distance * Math.cos(elevation);
        this.camera.position.z = centerZ + distance * Math.sin(elevation) * Math.sin(azimuth);
        this.camera.lookAt(centerX, centerY, centerZ);
      }

      /**
       * Adjusts the renderer and camera aspect ratio on resize.
       */
      handleResize() {
        const width = this.container.clientWidth;
        const height = this.container.clientHeight;
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
      }

      /**
       * Animation loop that continuously renders the scene.
       */
      animate() {
        this.renderer.render(this.scene, this.camera);
        requestAnimationFrame(this.animate);
      }

      /**
       * Loads new house geometry into the scene.
       * @param {HouseData} houseData Structured description of the house.
       */
      loadHouse(houseData) {
        while (this.houseGroup.children.length > 0) {
          const child = this.houseGroup.children.pop();
          this.houseGroup.remove(child);
        }

        houseData.blocks.forEach((block) => {
          const mesh = block.type === 'stair'
            ? this.#createStairMesh(block)
            : this.#createBlockMesh(block);
          mesh.userData.isBlock = true;
          this.houseGroup.add(mesh);
        });

        const { width, height, depth } = houseData.dimensions;
        this.updateCamera(width / 2, height / 2, depth / 2);
      }

      /**
       * Builds a unit block mesh with edge helpers.
       * @param {BlockData} block Block definition.
       * @returns {THREE.Mesh} Renderable block mesh.
       * @private
       */
      #createBlockMesh(block) {
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshLambertMaterial({ color: PALETTE.block });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(block.x + 0.5, block.y + 0.5, block.z + 0.5);
        this.#addEdges(mesh, geometry);
        return mesh;
      }

      /**
       * Builds a stair mesh honoring facing and upside-down metadata.
       * @param {BlockData} block Stair definition.
       * @returns {THREE.Group} Renderable stair group.
       * @private
       */
      #createStairMesh(block) {
        const group = new THREE.Group();
        const material = new THREE.MeshLambertMaterial({ color: PALETTE.stair });

        const bottomGeometry = new THREE.BoxGeometry(1, 0.5, 1);
        const bottomStep = new THREE.Mesh(bottomGeometry, material);
        bottomStep.position.set(0, -0.25, 0);
        this.#addEdges(bottomStep, bottomGeometry);
        group.add(bottomStep);

        const topGeometry = new THREE.BoxGeometry(1, 0.5, 0.5);
        const topStep = new THREE.Mesh(topGeometry, material);
        const upsideDown = Boolean(block.metadata?.upsideDown);
        topStep.position.set(0, 0.25, upsideDown ? -0.25 : 0.25);
        this.#addEdges(topStep, topGeometry);
        group.add(topStep);

        const rotations = {
          north: 0,
          east: Math.PI / 2,
          south: Math.PI,
          west: -Math.PI / 2,
        };

        group.rotation.y = rotations[block.metadata?.facing] || 0;
        if (upsideDown) {
          group.rotation.z = Math.PI;
        }

        group.position.set(block.x + 0.5, block.y + 0.5, block.z + 0.5);
        return group;
      }

      /**
       * Adds thin edge lines around a geometry for clarity.
       * @param {THREE.Mesh} mesh Mesh receiving the edges.
       * @param {THREE.BufferGeometry} geometry Geometry used to compute edges.
       * @private
       */
      #addEdges(mesh, geometry) {
        const edges = new THREE.EdgesGeometry(geometry);
        const material = new THREE.LineBasicMaterial({ color: 0x000000 });
        const wireframe = new THREE.LineSegments(edges, material);
        mesh.add(wireframe);
      }
    }

    const container = document.getElementById('canvas-container');
    const renderer = new HouseRenderer(container);
    const statusElement = document.getElementById('status');
    const statsElement = document.getElementById('stats');
    const fileInput = document.getElementById('fileInput');

    /**
     * Updates the sidebar statistics with block counts and dimensions.
     * @param {HouseData} houseData Parsed house payload.
     */
    function updateStats(houseData) {
      const counts = houseData.blocks.reduce((acc, block) => {
        acc[block.type] = (acc[block.type] || 0) + 1;
        return acc;
      }, {});

      const { width, height, depth } = houseData.dimensions;
      let html = '';
      html += `<div class="stat-item"><strong>Dimensions:</strong> ${width} × ${height} × ${depth}</div>`;
      html += `<div class="stat-item"><strong>Total blocks:</strong> ${houseData.blocks.length}</div>`;

      Object.entries(counts).forEach(([type, total]) => {
        html += `<div class="stat-item"><strong>${type}:</strong> ${total}</div>`;
      });

      statsElement.innerHTML = html;
    }

    /**
     * Displays a status message with optional tone styling.
     * @param {string} message Message to display.
     * @param {('info'|'error'|'success')} tone Visual tone.
     */
    function setStatus(message, tone = 'info') {
      statusElement.textContent = message;
      statusElement.className = 'status';
      if (tone === 'error') {
        statusElement.classList.add('--error');
      } else if (tone === 'success') {
        statusElement.classList.add('--success');
      }
    }

    /**
     * Loads and validates JSON data, updating the renderer and stats.
     * @param {HouseData} jsonData Parsed JSON payload.
     */
    function loadHouseFromJSON(jsonData) {
      if (!jsonData?.blocks || !jsonData?.dimensions) {
        throw new Error('Missing required keys: blocks and dimensions.');
      }
      renderer.loadHouse(jsonData);
      updateStats(jsonData);
    }

    /**
     * Handles manual file selection from the <input type="file"> element.
     * @param {Event} event Input change event.
     */
    function handleFileSelection(event) {
      const file = event.target.files?.[0];
      if (!file) return;

      setStatus('Loading file…');
      const reader = new FileReader();
      reader.onload = (loadEvent) => {
        try {
          const json = JSON.parse(loadEvent.target?.result ?? '');
          loadHouseFromJSON(json);
          setStatus('House loaded successfully.', 'success');
        } catch (error) {
          console.error(error);
          setStatus('Invalid JSON structure.', 'error');
        }
      };

      reader.onerror = () => {
        setStatus('Unable to read the selected file.', 'error');
      };

      reader.readAsText(file);
    }

    /**
     * Attempts to load house.json located next to this HTML file.
     */
    async function tryAutoLoad() {
      try {
        const response = await fetch('./house.json', { cache: 'no-store' });
        if (!response.ok) {
          throw new Error('house.json not found.');
        }
        const data = await response.json();
        loadHouseFromJSON(data);
        setStatus('Auto-loaded house.json.', 'success');
      } catch (error) {
        console.info('Auto-load skipped:', error.message);
        setStatus('Awaiting input…');
      }
    }

    fileInput.addEventListener('change', handleFileSelection);
    tryAutoLoad();
  </script>
</body>
</html>